# 1. 기본문법

> **참고**  [디모의 Kotlin 강좌](https://www.youtube.com/playlist?list=PLQdnHjXZyYadiw5aV3p6DwUdXV2bZuhlN)
>
## 1) 코틀린의 특징

- 자바를 대체하기 위한 목적으로 만들어짐
- JVM 호환될 수 있도록 만들어짐
- 기존에 자바로 개발이 가능했던 웹서비스/안드로이드/자바스크립트/Swift와 연동 가능

```kotlin
fun main() {
  println("Hello, world!!!!!")
}
```

## 2) 변수와 자료형

- 주석 :
  //  
  /* 주석
*  여러
*  줄 */
- 구문 끝나는 부분에서 세미콜론 안 붙여도 됨
- 변수  :
  var - 일반적인 변수. 언제든지 읽/쓰 가능
  val - 선언시에만 초기화 가능. 중간에 값 변경 불가능

```kotlin
fun main() {
	var a: Int
	println(a) // <---- 오류남!! 코틀린의 특징. 기본 변수에서 null 허용하지 않음
}

fun main() {
	var a: Int = 123
	println(a) 
}

fun main() {
	var a: Int? = null // 이렇게 쓰면 nullable 변수라는 의미. 다만 null point exception은 발생 가능
	println(a) 
}
```

- 자료형 :
- 정수형 : 8진수 지원x

```kotlin
var intValue:Int = 1234 // 32bit 이내 10진수
var longValue:Long = 1234L // 64bit Long 타입의 10진수
var intValueByHex:Int= 0x1af // 16진수
var intValueByBin:Int = 0b1 // 2진수
```

       - 실수형 

```kotlin
var doubleValue:Double = 123.5
var doubleValueWithExp:Double = 123.5e10
var floatValue:Float = 123.5f
```

        - 문자형 : 한 글자가 2bytes메모리 공간 사용

```kotlin
var charValue:Char = 'a'
var koreanCharValue:Char = '가'
```

        - 논리형 : Boolean

```kotlin
var booleanValue:Boolean = true
```

        - 문자열

"""여러줄의
문자열"""

```kotlin
var stringValue = "one line string test"
var multiLineStringValue = """multiline
string
test"""""
```

## 3) 형변환과 배열

- 형변환 : 코틀린은 암시적 형변환은 지원X. 명시적 변환만 지원

```kotlin
var a: Int = 54321
var b: Long = a.toLong()
```

- 배열

```kotlin
var intrr = arrayOf(1, 2, 3, 4,5)
var nullArr = arrayOfNulls<Int>(5) // null로 채워진 배열

intArr[2] = 8
println(intArr[4])
```

## 4) 타입추론과 함수

- 타입추론 :
- 변수나 함수들을 선언할 때나 연산이 이루어질 때 자료형을 코드에 명시하지 않아도 코틀린이 자동으로 자료형을 추론해주는 기능
- 반드시 특정한 자료형을 가져야하는게 아니라면 대부분에 이 기능을 사용하여 코드양을 줄일 수 있다!

```kotlin
var intArr**:Array<Int>** = arrayOf(1,2,3,4,5) // 빨간색 자료형 선언 생략해도 되는 것
```

- 함수 :
- 코틀린에서 함수는 내부적으로는 기능을 가진 형태이지만, 외부에서 볼 때는 파라미터를 넣는다는 점 외에는 '자료형이 결정된 변수' 로 접근하는게 좋다. ⇒ 함수형 언어라는 코틀린의 중요한 특징

```kotlin
fun main() {
	println(add(5, 6, 7))
}

fun add(a: Int, b: Int, c: Int) : Int { // : Int 로 명시한 것도 생략가능
	return a + b + c
}

// 위 함수 단일 표현식 함수로 바꿔보자
fun add(a: Int, b: Int, c: Int) = a + b + c // 마찬가지로 반환형도 생략가능
```

## 5) 조건문과 비교연산자

- 조건문
  - when 문

```kotlin
fun main() {
	doWhen(1)
	doWhen(12L)
	doWhen("Kotlin")
}

fun doWhen (a: Any) { // Any : 아무 자료형이나 가능하다
	var result = when(a) {
		1 -> println("정수 1")
		"K" -> println("K")
		is Long -> println("Long Type")
		!is String -> println("not String Type")
		else -> println("어떤 조건도 만족X")
	}
}
```

## 6) 반복문과 증감연산자

- 반복문

```kotlin
fun main() {
	for (i in 0..9 step 3) {
		print(i) // 0369 출력
	}
	
	for (i in 9 downTo 0) {
		print(i) // 9876543210 출력
	}
}
```

- 증감연산자 : - -a, a- -, ++a, a++

## 7) 흐름제어와 논리연산자

- 흐름제어 : continue, break, **label**

```kotlin
fun main() {
	loop@for (i in 1..10) {
			for (j in 1..10) {
				if (i == 1 && j == 2) break@loop
				println ("i : $i, j : $j")
			}
	}
}
```

- 논리연산자 : $$, ||

## 8) 클래스의 기본구조

- 속성(고유의 특징값) + 함수(기능의 구현) 으로 이루어짐

```kotlin
fun main() {
	var a = Person("홍길동", 1990)
	var b = Person("성춘향", 1999)

	a.introduce()
	b.introduce()
}

class Person(var name:String, val birthYear:Int) {
	fun introduce() {
		println ("Hi,  ${birthYear} 년생 ${name} 입니다");
	}
}
```

## 9) 클래스의 생성자

- 기본 생성자 : 클래스를 만들 때 기본적으로 선언
- 보조 생성자 : 필요에 따라 추가적으로 선언. constructor 라는 키워드 사용

```kotlin
fun main() {
	var a = Person("홍길동", 1990)
	var b = Person("성춘향", 1999)

	var c = Person("차은우")

}

class Person(var name:String, val birthYear:Int) {
	init {
		println ("${this.birthYear} 년생 ${this.name}님이 생성되었습니다.");
	}
	constructor(name:String) : this(name, 1997) { // 보조생성자
		println("보조 생성자가 사용되었습니다.")
	}
}
```

## 10) 클래스의 상속

- 클래스가 필요한 경우 - 기존 클래스 사용 / 여러 클래스 중 공통적인 걸 뽑아낼 때
  - 특징 1) super 클래스에 존재하는    속성과 '같은 이름'의 속성을 가질 수 없음
    특징 2) sub 클래스가 생성될 때에는 반드시 super클래스의 생성자까지 호출되어야 함
- 클래스의 상속은 클래스를 더 구조적으로 다룰 수 있게 해준다는 장점이 있지만,
  지나친 상속구조는 코드를 더 어렵게 만든다는 단점도 있음

```kotlin
fun main() {
	var a = Animal("별이", 5, "개")
	var b = Dog("별이", 5)

	a.introduce()
	b.introduce()

	b.bark()

	var c = Cat("루이", 1)
	
	c.introduce()
	c.meow()
}
open class Animal (var name:String, var age:Int, var type:String)
{
	fun introduce() {
		println ("저는 ${type} ${name}이고, ${age}살 입니다.");
	}
}

class Dog (name:String, age:Int) : Animal (name, age, "개") 
{
	fun bark() {
		println ("멍멍")
	}
}

class Cat (name:String, age:Int) : Animal (name, age, "고양이") 
{
	fun meow() {
		println ("야옹")
	}
}
```

## 11) 오버라이딩과 추상화

- 슈퍼클래스에서 'open'이 붙은 함수는 서브클래스에서 override를 붙여 재구현 가능

```kotlin
fun main () {
	var t = Tiger()
	t.eat() // 고기를 먹습니다 출력
}

open class Animal {
	fun eat() {
		println("음식을 먹습니다") 
	}
}

class Tiger : Animal() {
	override fun eat() {
		println("고기를 먹습니다") 
	}
}
```

- 추상화 : 추상함수(선언부만 있고 기능부는 구현되지 않은), 추상(추상함수를 포함하는 추상클래스)로 구성
  - abstract 클래스는 단독으로 인스턴스를 만들 수 없다.
    반드시 서브클래스에서 상속받아 abstract 표시가 된 함수들을 구현해줘야 한다.

```kotlin
fun main () {
	var r = Rabbit()
	
	r.eat()
	r.sniff()
}

abstract class Animal {
	abstract fun eat()//Animal을 상속받는 서브클래스에서 override 키워드와 함께 반드시 구현해야함
	fun sniff() {
		println("킁킁")
	}
}

class Rabbit : Animal() {
	override fun eat() {
		println("당근을 먹습니다")
	}
}
```

- 인터페이스 :  추상함수, 일반함수 모두 가질 수 있음
- 인터페이스, 추상함수 차이
  - 추상함수 : 생성자를 가질 수 있음
  - 인터페이스 : 1) 생성자를 가질 수 없음
    2) 구현부가 있는 함수 → open 함수로 간주
    구현부가 없는 함수 → abstract 함수로 간주
    ⇒ 별도로 키워드가 없어도 포함된 모든 함수를 서브클래스에서 구현 및 재정의가 가능

                           3) 다중 상속 가능


```kotlin
fun main() {
    var d = Dog()
    d.run()
    d.eat()
}

interface Runner {
    fun run()
}

interface Eater {
    fun eat() {
        println ("음식을 먹습니다")
    }
}

class Dog : Runner, Eater { // 두 인터페이스 상속
    override fun run() {
        println ("뜁니다")
    }
}
```

즉, 추상화는 형식만 선언하고 실제 구현은 서브클래스에 일임할 때 사용,
인터페이스는 서로 다른 기능들을 여러개 물려주어야 할 때 유용한 기능

## 12) 기본 프로젝트 구조

- 코틀린은 자바와 달리 폴더 구조와 패키지명을 일치시키지 않아도 된다.
- 코틀린은 자바와 달리클래스명과 파일명이 일치시키지 않아도 된다. 또 하나의 파일에 여러개의 클래스가 있어도 가능하다.
- 단순히 파일 상단에 패키지명만 명시해주면 컴파일러가 알아서 처리한다.
- import + 사용할 패키지의 변수/함수를 작성하여서도 사용 가능

## 13) 스코프와 접근제한자

- 스코프  : 언어차원에서 '멤버'들을 서로 공유할 수 있는 범위

  1) 스코프 외부에서는 스코프 내부의 멤버를 '참조연산자'로만 참조가 가능하다. (ex a.eat(), import)

  2) 동일 스코프 내에서는 멤버들을 공유할 수 있다.

    ```kotlin
    val a = "패키지 스코프"
    
    class B {
    	fun print() {
    			println(a)
    	}
    }
    
    fun main () {
    	println(a)
    	B().print()
    }
    ```

  3) 하위 스코프에서는 같은 이름의 멤버를 만들어 사용할 수 있다.

    ```kotlin
    val a = "패키지 스코프"
    
    class B {
    	val a = "클래스 스코프"
    	fun print() {
    			println(a)
    	}
    }
    
    fun main () {
    	var a = "함수 스코프"
    	println(a)
    	B().print()
    }
    ```

- 접근제한자 : 스코프 외부에서 내부에 접근할 때 그 권한을 개발자가 제한할 수 있음


    | 패키지 스코프 | 1) public(기본값) : 어떤 패키지에서도 접근 가능
    2) internal : 같은 모듈 내에서만 접근 가능
    3) private : 같은 파일 내에서만 접근 가능
    * protected는 사용하지 않음 |
    | --- | --- |
    | 클래스 스코프 | 1) public(기본값) : 클래스 외부에서 늘 접근 가능
    2) private : 클래스 내부에서만 접근 가능
    3) protected : 클래스 자신과 상속받은 클래스에서 접근 가능
    * internal은 사용하지 않음 |

## 14) 고차함수와 람다함수

- 고차함수 : 함수를 마치 클래스에서만들어 낸 인스턴스처럼 취급하는 방법.
  함수를 파라미터 취급할 수도 있고, 결과값으로 반환받을 수도 있음.
  코틀린에선 모든 함수를 고차함수로 사용 가능

```kotlin
fun main() {
		b(::a) // 고차함수 형태로 넘기려면 :: 쓰면됨
}

fun a (str: String) {
	println("$str 함수 a")
}

fun b (function: (String)->Unit) { // Unit : 반환값이 없다는 의미
	function("b가 호출한:)
}
```

- 람다함수 : 일반함수와 달리 그 자체가 고 별도의 연산자 없이 함수에 담을 수 있다.

```kotlin
fun main() {
		b(::a) // 고차함수 형태로 넘기려면 :: 쓰면됨
		val c: (String) ->Unit = { str -> println("$str 람다함수")}
		b(c)
}

fun a (str: String) {
	println("$str 함수 a")
}

fun b (function: (String)->Unit) { // Unit : 반환값이 없다는 의미
	function("b가 호출한:)
}
```

## 15) 스코프 함수

- 스코프함수 : - 함수형 언어의 특징을 좀 더 편하게 사용할 수 있도록 기본으로 제공하는 함수

                        - 인스턴스의 속성이나 함수를 scope 내에서 깔끔하게 분리가 가능해 코드 가독성 향상시킴

  - apply : 인스턴스를 생성한 후 변수에 담기 전에 '초기화 과정' 을 할 때 사용.
    main 함수와 별도의 scope에서 인스턴스의 변수와 함수를 조작하므로 코드가 깔끔해진다

    ```kotlin
    fun main() {
    	var a = Book("어린왕자", 10000).apply {
    			name = "[이달의 책]" + name
    			discount()
    	}
    }
    
    class Book(var name: String, var price: Int) 
    {
    	fun discount()
    	{
    		price -= 2000
    	}	
    }
    ```

  - run : 이미 인스턴스가 만들어진 후에 인스턴스의 함수 내 속성을 scope내에서 사용해야 할 때 유용

    ```kotlin
    fun main() {
    	var a = Book("어린왕자", 10000).apply {
    			name = "[이달의 책]" + name
    			discount()
    	}
    	a.run {
    		println("상품명: ${name}, 가격: ${price}원")
    	}
    }
    
    class Book(var name: String, var price: Int) 
    {
    	fun discount()
    	{
    		price -= 2000
    	}	
    }
    ```

  - with : run과 동일한 기능을 가지지만 단지 인스턴스를 참조연산자 대신 파라미터로 받을 수 있음

                  [a.run](http://a.run) {...}

                  with**(a)** {...}

  - apply / also : 처리가 끝나면 인스턴스를 반환
  - run / let : 처리가 끝나면 최종값을 반환
  - apply / run : 참조연산자 없이 인스턴스의 변수와 함수를 사용할 수 있음
  - also / let : 파라미터로 인스턴스를 넘긴 것 처럼 사용 가능

    ⇒ 왜 굳이 파라미터로?  같은 이름의 변수나 함수가 scope 바깥에 중복되어있는 경우 혼란을 방지하기 위해!

      ```kotlin
      fun main() {
          var price = 5000
      
          var a = Book("어린왕자", 10000).apply {
                  name = "[이달의 책]" + name
                  discount()
          }
          a.run {
              println("상품명: ${name}, 가격: ${price}원") // 가격 5000원 출력됨!!!!
          }
          a.let {
              println("상품명: ${it.name}, 가격: ${it.price}원") // 가격 000원 출력됨!!!!
          
      }
      
      class Book(var name: String, var price: Int) 
      {
          fun discount()
          {
              price -= 2000
          }	
      }
      ```



## 16) 오브젝트

- 오브젝트 : - 인스턴스를 생성하지 않고 그 자체로 객체이기 때문에 생성자는 사용하지 X.
  - 오브젝트로 선언된 객체는 최초 사용시 자동으로 생성되며, 이후에는 코드 전체에서 공용으로 사용 될 수 있으므로 프로그램이 종료되기 전까지 공통적으로 사용할 내용들을 묶어 만드는게 좋다.

    ```kotlin
    fun main() {
        println(Counter.count)
    
        Counter.countUp()
        Counter.countUp()
    
        println(Counter.count)
    
        Counter.clear()
    
        println(Counter.count)
    
    }
    object Counter {
        var count = 0
    
        fun countUp() {
            count++
        }
        fun clear() {
            count = 0
        }
    }
    ```

- Companion object - 클래스의 인스턴스 기능은 그대로 사용하면서, 인스턴스간의 공용으로 사용할 속성과 함수를 별도로 만드는 기능. static과 비슷하다고 생각하면 됨

    ```kotlin
    fun main() {
        var a = FoodPoll("pizza")
        var b = FoodPoll("pasta")
    
        a.vote()
        a.vote()
        
        b.vote()
        b.vote()
        b.vote()
        
        println("${a.name} : ${a.count}")
        println("${b.name} : ${b.count}")
        println("총계 : ${FoodPoll.total}")
        
    }
    
    class FoodPoll (val name: String) {
        companion object {
            var total = 0
        }
        
        var count = 0
        
        fun vote() {
            total++
            count++
        }
    }
    ```
  ## 17) 익명객체와 옵저버 패턴

- 옵저버 : 이벤트가 일어나는 것을 감시하는 감시자의 역할 (ex. 폰에서 키 입력 시 즉각 처리)
- 옵저버 패턴을 구현할 때는 두 개의 클래스가 필요. 1) 이벤트 수신 클래스 2) 이벤트 발생 및 전달 클래스
  이 두 클래스 사이에 인터페이스를 끼워넣는데, 이 때 해당 인터페이스를 옵저버라하고 코틀린에선 리스터라 부른다. 또한 이벤트를 넘겨주는 행위를 콜백이라고 한다.

    ```kotlin
    fun main() {
        EventPrinter().start()
    }
    
    interface EventListener {
        fun onEvent(count: Int)
    }
    
    class Counter(var Listner: EventListener) {
    
        fun count() {
            for(i in 1..100) {
                if(i % 5 == 0) listener.onEvent(i)
            }
        }
    }
    
    class EventPrinter: EventListener {
        override fun onEvent(count: Int) {
            print("${count}-")
        }
    }
    ```

- 익명객체 : 위 예제에서 EventPrinter 가 EventListener를 상속받아 구현하지 않고 임시로 만든 별도의 EventListener 객체를 대신 넘겨줄 수도 있다. object 키워드를 사용한다.
  (+) 클래스의 인스턴스를 여러개 만들 필요가 없는 경우 클래스를 미리 만들어 두는 것은 자원의 낭비

    ```kotlin
    fun main() {
        EventPrinter().start()
    }
    
    interface EventListener {
        fun onEvent(count: Int)
    }
    
    class Counter(var Listner: EventListener) {
    
        fun count() {
            for(i in 1..100) {
                if(i % 5 == 0) listener.onEvent(i)
            }
        }
    }
    
    class EventPrinter {
        fun start() {
            val counter = Counter(object: EventListener {
                override fun onEvent(count: Int) {
                    print("${count}-")
                }
            })
            counter.count()
        }
    }
    ```
 ## 18) 클래스의 다형성

- 다형성 : 클래스의 상속관계에서 오는 인스턴스의 호환성을 적극 활용할 수 있는 기능으로 수퍼클래스와 같은 인스턴스를 한 번에 관리하거나 인터페이스를 구현하여 사용하는 코드에서도 사용됨
- as : 변수를 호환되는 자료형으로 변환해주는 캐스팅 연산자
- is : 변수가 자료형에 호환되는지를 먼저 체크한 후 변환해주는 캐스팅 연산자

```kotlin
fun main() {
    var a = Drink()
    a.drink()

    var b: Drink = Cola()
    b.drink()

    // b.washDishes() // 참조 불가 에러 발생.
    
    if(b is Cola) // is 는 조건문 안에서만 다운캐스팅
    {
        b.washDishes() 
    }
    var c = b as Cola
    c.washDishes() 
    b.washDishes() // 아까와 달리 참조 가능. as 사용 시 변수 자체도 다운캐스팅이 되기 때문!
}

open class Drink {
    var name = "음료"

    open fun drink() {
        println("${name}를 마십니다")
    }
}

class Cola: Drink() {
    var type = "콜라"

    override fun drink() {
        println("${name}중에 ${type}를 마십니다")
    }

    fun washDishes() {
        println("${type}로 설거지를 합니다")
    }
}
```
## 19) Generic

- Generic : 클래스나 함수에서 사용하는 자료형을 외부에서 지정할 수 있는 기능.
  함수나 클래스를 선언할 때 고정적인 자료형 대신 실제 자료형으로 대체되는 타입 파라미터를 받아 사용
  사용 예 - <T>, <T, U, V>, <T: SuperClass>

```kotlin
fun main() {
    UsingGeneric(A()).doShouting()
    UsingGeneric(B()).doShouting()
    UsingGeneric(C()).doShouting()

    doShouting(B()) // 캐스팅 없이 B의 객체 그대로 함수에서 사
}

fun <T: A> doShouting(t: T) {
     t.shout()
}

open class A {
    open fun shout() {
        println("A shout")
    }
}

class B : A() {
    open fun shout() {
        println("B shout")
    }
}

 class C : A() {
    open fun shout() {
        println("A shout")
    }
}

class UsingGeneric<T: A> (val t: T){
    fun doShouting() {
        t.shout()
    }
}
```

## 20) 리스트

- 리스트 : 데이터를 모아 관리하는 Collection 클래스를 상속받는 서브 클래스 중 가장 단순한 형태.
  여러개의 데이터를 원하는 순서로 넣어 관리하는 형태.
1) List - 객체 추가/수정/삭제 불가능
2) MutableList - 객체 추가/수정/삭제 가능. add, remove 메서드 이외 shuffle, sort 메서드도 있음

```kotlin
fun main() {

    val a = listOf("A", "B", "C");
    println(a[1])

    for(fruit in a) {
        print("{fruit}:")
    }
    println()

    val b = mutableListOf(6, 3, 1)
    println(b)

    b.add(4)
    println(b)

    b.add(2, 8)
    println(b)
    
    b.removeAt(1)
    println(b)
    
    b.shuffle()
    println(b)
    
    b.sort()
    prinln(b)
}
```
## 21) 문자열

- 코틀린에선 Split에 정규식이 아닌 일반 문자열을 넣어도 동작함
- `isNullOrBlank법()` - 공백만 있어도 true로 리턴

```kotlin
fun main() {

    val test1 = "Test.Kotlin.String"

    println(test1.length)

    println(test1.toLowerCase());
    println(test1.toUpperCase());

    val test2 = test1.split(".")
    println(test2)

    println(test2.joinToString())
    println(test2.joinToString("-"))

    println(test1.substring(5..10))

    val nullString: String? = null
    val emptyString = ""
    val blankString = " "
    val normalString = "A"

    println(nullString.isNullOrBlank())
    println(emptyString.isNullOrBlank())
    println(blankString.isNullOrBlank())
    println(normalString.isNullOrBlank())

    var test3 = "kotlin.kt"
    val test4 = "java.java"

    println(test3.startsWith("java"))
    println(test4.startsWith("java"))

    println(test3.endsWith(".kt"))
    println(test4.endsWith(".kt"))

    println(test3.contains("lin"))
    println(test4.contains("lin"))
}
```

## 22) null 처리 및 변수 동일성 체크 방법

### null 처리

- 기본적으로 코틀린은 변수에 null값을 넣지 못함
- nullable 변수를 만들 수 있기는 하지만 이 변수를 사용할 때에는 null 체크없이는 코드가 컴파일이 되지 않음!
- if로 체크하지 않고도 참조 연산자 앞에 **?.**      **?:**       **!!.** 를 사용할 수 있음
- ?. (null safe operator)
  - 앞의 변수가 null이 아닐 때에만 오른쪽 함수가 수행되고 null이면 null 반환
- ?: (Elvis operator)
  - null인 경우 default값을 주고 싶을 때
- !!.
  - null값이 절대 들어오면 안되는 경우에 사용

```kotlin
fun main() {

    var a: String? = null

    println(a?.toUpperCase())
    println(a?:"default".toUpperCase())
    println(a!!.toUpperCase()) // NPE 발

    a?.run { // null 일 땐 실행이 되지 않음
        println(toUpperCase())
        println(toLowerCase())
    }

}
```

### 동일성 체크

- 내용의 동일성 : a == b
  ⇒ 코틀린의 모든 클래스가 내부적으로 상속받는 Any라는 최상위 클래스의 equals() 함수가 반환하는 Boolean 값으로 판단하게 된다. 커스텀 클래스를 만들 때에는 이 equals()를 override 하여 별도로 구현해야한다.
- 객체의 동일성 : a === b

```kotlin
fun main() {
    var a = Product("coke", 1000)
    var b = Product("coke", 1000)
    var c = a
    var d = Product("juice", 1000)

    println(a == b)
    println(a === b)

    println(a == c)
    println(a === c)

    println(a == d)
    println(a === d)

}

class Product(val name: String, val price: Int) {
    override fun equals(other: Any?): Boolean {
        if (other is Product) {
            return other.name == name && other.price == price
        } else {
            return false
        }
    }
}
```