# 2. 함수형 프로그래밍

## 2.8 컬렉션

- 일반적으로 함수형 프로그래밍에서는 불변(immutable) 자료구조를 사용
- 불변 자료구조는 객체의 상태 변화를 미연에 방지하여 부수효과를 근본적으로 방지
- 코틀린에서의 불변/가변 자료구조
    - 불변
        - List, Set, Map
    - 가변
        - MutableList, MutableSet, MutableMap
- add 함수 사용하려면 mutable 사용

## 5.2 컬렉션 데이터 걸러내기

- 명령형 vs 함수형
    - 매개변수로 받은 리스트에서 짝수만 걸러내는 함수 비교
    - 명령형

    ```kotlin
    fun imperativeFilter(numList: List<Int>): List<Int> {
    	val newList = mutableListOf<Int>()
    	for (num in numList) {
    		if (num % 2 == 0) {
    			newList.add(num)
    		}
    	}
    }
    ```

    - 함수형

    ```kotlin
    fun functionalFilter(numList: List<Int>): List<Int> = 
    	numList.filter { it % 2 == 0}
    ```

    - 위 예제에서 함수형으로 작성했을 때의 장점
        - 간결 및 가독성
        - 결과값을 저장하기 위해 별도의 리스트 생성X
        - 테스트 및 유지보수 용이

## 5.3 컬렉션 데이터 변경하기

- 명령형 vs 함수형
    - 입력받은 리스트의 모든 값에 2 더하는 함수
    - 명령형

    ```kotlin
    fun imperativeMap(numList: List<Int>): List<Int> {
    	val newList = nutableListOf<Int>()
    	for (num in numList) {
    		newList.add(num + 2)
    	}
    	return newList
    }
    ```

    - 함수형

    ```kotlin
    fun functionalMap(numList: List<Int>): List<Int> {
    	return numList.map { it + 2}
    }
    ```

    - 위 예제에서 함수형으로 작성했을 때의 장점
        - 원본 리스트를 변경하지 않고 내부적으로 새로운 리스트를 만들어서 반환하기 때문에 부수효과가 없다