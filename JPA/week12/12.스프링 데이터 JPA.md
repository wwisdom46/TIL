# Chapter 12 스프링 데이터 JPA

---

## 시작에 앞서

- 대부분의 데이터 접근 계층(Data Access Layer)은 일명 CRUD로 부르는 유사한 등록, 수정,삭제 조회 코드를 반복해서 개발해야한다.
- JPA를 사용해서 데이터 접근 계층을 개발할 때에도 이 같은 문제가 발생한다.

```java
public class MemberRepository {

    @PersistenceContext
    public EntityManager em;
    public void save(Member member) {...}
    public Member findOne(Long id) {...}
    public List<Member> findAll() {...}
    public Member findByUsername(String username) {...}
}

public class ItemRepository {

    @PersistenceContext
    public EntityManager em;
    public void save(Item item) {...}
    public Item findOne(Long id) {...}
    public List<Item> findAll() {...}

}
```

- 위 예제를 보면 MemberRepository와 ItemRepository가 하는 일이 비슷하다.
- JPA를 사용해도 대부분의 데이터 접근 계층은 CRUD라고 하는 코드를 반복해서 개발해야 하는 문제점이 존재한다. 이러한 단점을 해결하기 위해 나온 것이 `Spring Data JPA`이다.

## 12.1 스프링 데이터 JPA 소개

- `Spring Data JPA` 는 스프링 프레임워크에서 JPA를 편리하게 사용할 수 있도록 지원하는 프로젝트다.
- 위와 같은 단순하고 반복적인 CRUD 문제를 해결한다.
- 레포지토리를 개발할 때 인터페이스만 작성하면 실행 시점에 `Spring Data JPA`가 구현 객체를 동적으로 생성해서 주입해준다. 따라서 개발자가 직접 구현체를 개발하지 않아도 된다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
    Member findByUsername(String username);
}

public interface ItemRpository extends JpaRepository<Item, Long> {
}
```

- 클래스 다이어 그램

![12.1](./resources/12.1.png)

- 일반적인 CRUD 메소드는 JpaRepository 인터페이스가 공통으로 제공하므로 문제가 없다.
- 하지만 MemberRepository.findByUsername(…) 처럼 직접 작성한 메소드는 어떻게 해야할까?
- 놀랍게도 `Spring Data JPA`는 메소드 이름을 분석해서 다음 JPQL을 실행한다.
    - select m from Member m where username =:username

### 12.1.1 스프링 데이터 프로젝트

- `Spring Data JPA`는 스프링 데이터 프로젝트의 하위 프로젝트 중 하나이다.

![12.2](./resources/12.2.png)

- `Spring Data 프로젝트`는 JPA, MongoDB, NEO4J, Redis, HADDOP, GEMFIRE 같은 다양한 데이터 저장소에 대한 접근을 추상화하여 반복적인 데이터 접근 코드를 줄여준다.
- 여기서 `Spring Data JPA 프로젝트`는 JPA에 특화된 기능을 제공한다.

## 12.2 스프링 데이터 JPA 설정

- 필요 라이브러리

```java
// gradle
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'

// maven
<dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-jpa</artifactId>
    <version>1.8.0.RELEASE</version>
</dependency>
```

- 환경설정
    1. 스프링 설정에 XML을 사용하는 경우
        1.  <jpa:respositories>를 사용하고 repository를 검색할 base-package를 적으면 해당 패키지와 그 하위 패키지를 검색

        ```java
        // XML 설정
        <?xml version="1.0" encoding="UTF-8"?>
        <beans xmlns="http://www.springframework.org/schema/beans"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
               xmlns:jpa="http://www.springframework.org/schema/data/jpa"
               xsi:schemaLocation="http://www.springframework.org/schema/beans 
                  http://www.springframework.org/schema/beans/spring-beans.xsd 
                  http://www.springframework.org/schema/data/jpa 
                  http://www.springframework.org/schema/data/jpa/spring-jpa.xsd">
        
        	<jpa:repositories base-package="jpabook.jpashop.repository" />
            
        </beans>
        ```

    2. 스프링 설정에 JavaConfig를 사용하는 경우
        1. EnableJpaRepositories 어노테이션을 추가하고 basePackage에는 리포지토리를 검색할 패키지 위치를 적는다.

        ```java
        // JavaConfig 설정
        @Configuratrion
        @EnableJpaRepositories(basePackage = "jpabook.jpashop.repository")
        public class AppConfig {}
        ```

    3. 동작 과정
        1. `Spring Data JPA`는 애플리케이션을 실행할 때 basePackage에 있는 repository interface들을 찾아서 해당 인터페이스를 구현한 클래스를 동적으로 생성한 후, 스프링 빈으로 등록한다. 따라서 개발자가 직접 구현 클래스를 만들지 않아도 된다.
## 12.3 공통 인터페이스 기능

- `Spring Data JPA`는 간단한 CRUD 기능을 공통으로 처리하는 JpaRepository 인터페이스를 제공한다.
- `Spring Data JPA`를 사용하는 가장 단순한 방법은 이 인터페이스를 상속받는 것이며, 그 후 제네릭에 엔티티 클래스와 엔티티 클래스가 사용하는 식별자 타입을 지정하면 된다.

```java
public interface JpaRepository<T, ID extends Serializable> extends PagingAndSortingRepository<T, ID> {
    ...
}
```

```java
public interface MemberRepository extends JpaRepository<Member, Long> {
}
```

- JpaRepository 인터페이스를 상속받으면 사용할 수 있는 주요 메소드

  (여기에서 T는 엔티티, ID는 엔티티의 식별자 타입, S는 엔티티와 그 자식 타입을 뜻함)

- **save(S) :** 엔티티에 식별자가 없으면 EntityManager.persist()를 호출하여 새로운 엔티티는 저장하고식별자 값이 있으면 이미 있는 엔티티로 판단해서 EntityManager.merge()를 호출하여 수정
- **delete(T) :** 엔티티 하나를 삭제하며, 내부에서 EntityManager.remove()를 호출
- ️**findOne(ID) :** 엔티티 하나를 조회하며, 내부에서 EntityManager.find()를 호출
- **getOne(ID):** 엔티티를 프록시로 조회하며, 내부에서 EntityManager.getReference()를 호출
- **findAll(...) :** 모든 엔티티를 조회하며, 정렬이나 페이징 조건을 파라미터로 제공할 수 있음

## 12.4 쿼리 메소드 기능

- 스프링 데이터 JPA의 마법같은 기능
- ex. **메소드 이름 만으로 쿼리를 생성**하는 기능
- 인터페이스 메소드만 선언하면 메소드 이름으로 JPQL 쿼리를 생성해서 실행
- **스프링 데이터 JPA가 제공하는 쿼리 메소드 기능 3가지**
    - 메소드 이름으로 쿼리 생성
    - 메소드 이름으로 JPA NamedQuery 호출
    - @Query 어노테이션을 사용해서 Repository 인터페이스에 쿼리 직접 정의

### 12.4.1 메소드 이름으로 쿼리 생성

- 예시코드

```java
public interface MemberRepository extends Repository<Member, Long> {
    List<Member> findByEmailAndName(String email, String name);
}
```

- 인터페이스에 정의한 findByEmailAndName(…) 메소드를 실행하면, `Spring Data JPA`는 메소드 이름을 분석해서 JPQL을 생성하고 실행한다.

```sql
select m from Member m where m.email = ?1 and m.name = ?2
```

⭐️ 정해진 규칙에 따라 메소드 이름을 지어야 한다.

- 관련 메소드 링크

[https://docs.spring.io/spring-data/jpa/docs/1.3.0.RELEASE/reference/html/jpa.repositories.html](https://docs.spring.io/spring-data/jpa/docs/1.3.0.RELEASE/reference/html/jpa.repositories.html)