# 1.개발정리

- PC 1대로 여러 인스턴스 구성 시, 포트번호로 PC 여러대로 여러 인스턴스 구성 시에는 포트번호는 동일, 해당 서버 ip
- Eureka 역할 - Service Discovery
- (외부에서 다른 서비스이 micro service를 검색하기 위해서 사용되는 개념), 요청 정보가 들어왔을 때 이 정보가 어디에 있다고 알려주는 역할a
- API Gateway란?
    - 인증 및 권한 부여
    - 서비스 검색 통합
    - 응답 캐싱
    - 정책, 회로 차단기 및 QoS 다시 시도
    - 속도 제한
    - 부하 분산
    - 로깅, 추적, 상관 관계 (ex. ELK)
    - 헤더, 쿼리 문자열 및 청구 변환
    - IP 허용 목록에 추가

- Spring Cloud에서의 MSA간 통신
    - RestTemplate

    ```java
    RestTemplate restTemplate = new RestTemplate();
    restTemplate.getForObject("http://localhost:8080/", User.class, 200);
    ```

    - **Feign Client ⇒  직접적인 서버 ip,port,주소를 통한 호출이 아닌 마이크로서비스 이름으로 호출 가능**

    ```java
    @FeignClient("stores")
    public interface StoreClient {
    	@RequestMapping(method = RequestMethod.GET, value="/stores")
    	List<Store> getStores();
    ```


- Netflix Zuul 구현
    - gateway 역할
    - client ↔  Netflix Zuul ↔  Micro Service


- Spring Cloud Gateway - Filter
  - Pre Filter
  - Post Filter
- E-commerce 애플리케이션 구성

    | 구성요소 | 설명 |
    | --- | --- |
    | Git Repository | 마이크로서비스 소스 관리 및 프로파일 관리 |
    | Config Server | Git 저장소에 등록된 프로파일 정보 및 설정 정보 |
    | Eureka Server | 마이크로서비스 등록 및 검색 |
    | API Gateway Server | 마이크로서비스 부하 분산 및 서비스 라우팅 |
    | Microservices | 회원 MS, 주문 MS, 상품(카테고리) MS |
    | Queuing System | 마이크로서비스 간 메시지 발행 및 구독 |
- E-commerce 애플리케이션 APIs

    | 마이크로서비스 | RESTful API | HTTP Method |
    | --- | --- | --- |
    | Catalog Service | /catalog-service/catalogs : 상품 목록 제공 | GET |
    | User Service | /user-service/users : 사용자 정보 등록
    /user-service/users : 전체 사용자 조회
    /user-service/users/{user_id} : 사용자 정보, 주문 내역 조회 | POST
    GET
    GET |
    | Order Service | /order-service/users/{user_id}/orders : 주문 등록
    /order-service/users/{user_id}/orders : 주문 확인 | POST
    GET |

## 29) 변수의 고급 기술 - 상수, lateinit, lazy

- var
    - 한 번 할당한 객체 바꿀 수 있음

```kotlin
var a = Person("제임스", 1990)
a = Person("마이크", 1999)
```

- val
    - 한 번 할당한 객체 바꾸기 불가능. 다만 객체 내부의 속성은 변경할 수 있음.
- 상수
    - 컴파일 시점에 결정되어 절대 변경 불가능 val 앞에 const **val** CONST_A = 1234 식으로 사용
    - 변수의 경우 런타임 시 객체를 생성하는데 시간이 더 소요되어 성능을 하락시킬 수 있기 때문에 늘 고정적으로 사용할 값은 객체의 생성없이 메모리에 값을 고정하여 사용하는 상수를 쓰는게 좋음

```kotlin
fun main() {
    var foodCourt = FoodCourt()

    foodCourt.searchPrice(FoodCourt.FOOD_CREAM_PAST)
    foodCourt.searchPrice(FoodCourt.FOOD_STEAK)
    foodCourt.searchPrice(FoodCourt.FOOD_PIZZA)
}

class FoodCourt {
    fun searchPrice(foodName: String) {
        val price = when(foodName) {
            FOOD_CREAM_PAST -> 13000
            FOOD_STEAK -> 25000
            FOOD_PIZZA -> 15000
            else -> 0
        }
        println("${foodName}의 가격은 ${price}원 입니다")
    }

    companion object {
        const val FOOD_CREAM_PAST = "크림파스타"
        const val FOOD_STEAK = "스테이크"
        const val FOOD_PIZZA = "피자"
    }
}
```

- lazyinit
    - 경우에 따라 변수에 객체를 할당하는 것을 선언과 동시에 할 수 없을 때도 있음
    - 이 때 변수 앞에 **lazyinit** 키워드를 사용하여 초기값의 할당을 나중에 할 수 있도록 할 수 있음
    - 초기값 할당 전까지 변수를 사용할 수 없음 (사용 시 에러 발생)
    - 기본 자료형에는 사용할 수 없음
    - ::a**.isInitialized** - 초기화가 되었는지 확인 가능

```kotlin
import java.awt.SystemColor.text

fun main() {
    val a = LateInitSample()

    println(a.getLateInitText())
    a.text = "새로 할당한 값"
    println(a.getLateInitText())
}

class LateInitSample {
    lateinit var text: String

    fun getLateInitText(): String {
        if (::text.isInitialized) {
            return text;
        } else {
            return "기본값"
        }
    }
}
```

- lazy delegate properties (지연 대리자 속성)
    - 변수를 사용하는 시점까지 초기화를 자동으로 늦춰줌
    - lateinit과 달리 val a: Int by lazy {7} 와 같이 by 라는 키워드를 사용하여 lazy 라는 람다형태의 초기화 함수를 사용
    - 코드에서는 선언 시 즉시 객체를 생성 및 할당하여 변수를 초기화 하는 형태를 갖고 있지만 실제 실행시에는 val 변수를 사용하는 시점에 초기화 과정을 진행하여 코드의 실행 시간을 최적화 할 수 있음

```kotlin
fun main() {
    val number: Int by lazy {
        println("초기화")
        7
    }
    println("코드 시작")
    println(number)
    println(number)

    // 출력결과
    // 코드시작
    // 초기화
    // 7
    // 7 <------ 이미 초기화 되었기 때문에 다시 초기화 구문 실행하지 않고 바로 7 출력

}
```