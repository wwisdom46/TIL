# **79. 과도한 동기화는 피하라**

> 핵심 요약
>
- 교착 상태와 데이터 훼손을 피하려면 동기화 영역 안에서 외계인 메소드를 절대 호출하지 말자.
- 동기화 영역 안에서의 작업은 최소한으로 줄이자.
- 가변 클래스를 설계할 때는 스레드 안전한 클래스를 만들지에 대한 여부를 고민하자. 그리고 이를 문서에 명기하자.

동기화는 프로그램 안정성을 보장하기 위해 중요하지만, 과도하게 사용하면 성능 저하, 교착 상태, 예측할 수 없는 동작 등의 문제를 야기할 수 있다.

동기화된 영역에서는 클라이언트에게 제어를 양도하면 안 된다.

- 예를 들어, 재정의할 수 있는 메소드 호출이나 클라이언트가 전달한 함수 객체 호출은 동기화된 영역에서 예측 불가능한 문제를 발생시킬 수 있다.

# 외계인 메서드

응답 불가와 안전 실패를 유발할 수 있는 메서드 즉, 동기화된 영역에서 재정의할 수 있는 메서드 혹은 클라이언트가 넘겨준 함수 객체 등을 **동기화된 클래스 관점에서 외계인 메서드라고 한다.**

동기화된 클래스는 외계인 메서드가 무슨 일을 할지 알지 못하며 통제할 수도 없고 **외계인 메서드**가 하는 일에 따라 동기화된 영역은 예외를 일으키거나, 교착상태에 빠지거나, 데이터를 훼손할 수도 있다.

**동기화 블록 안에서 외부 메서드를 호출하는 잘못된 코드**

```java
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Set;

// 어떤 집합(Set)을 감싼 래퍼 클래스, 클래스의 클라이언트는 집합에 원소가 추가되면 알림을 받을 수 있음
public class ObservableSet<E> extends ForwardingSet<E> {

    public ObservableSet(Set<E> set) {
        super(set);
    }

    private final List<SetObserver<E>> observers = new ArrayList<>();

    public void addObserver(SetObserver<E> observer) {
        synchronized (observers) {
            observers.add(observer);
        }
    }
    
    public boolean removeObserver(SetObserver<E> observer) {
        synchronized (observers) {
            return observers.remove(observer);
        }
    }
    
    private void notifyElementAdded(E element) {
        synchronized (observers) {
            for(SetObserver<E> observer : observers) {
                observer.added(this, element);
            }
        }
    }
    
    @Override
    public boolean add(E element) {
        boolean added = super.add(element);
        if(added) {
            notifyElementAdded(element);
        }
        return added;
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        boolean result = false;
        for (E element : c) {
            result |= add(element); // notifyElementAdded를 호출한다.
            // |= OR 연산자. 하나라도 추가된 게 있으면 true
        }
        return result;
    }
}

```

- Set을 감싸는 래퍼 클래스인 ObservableSet 클래스는 관찰자 패턴을 구현한 것이다.
- 클라이언트가 이 클래스를 사용하면 집합에 원소가 추가되면 알림을 받을 수 있다.
- ForwardingSet 클래스를 재사용하여 구현하였으며, addObserver와 removeObserver 메소드로 구독 신청 및 해지를 할 수 있다.

```java
@FunctionalInterface
public interface SetObserver<E> {
    // ObservableSet에 원소가 추가되면 호출된다.
    void added(ObservableSet<E> set, E element);
}
```

- 관찰자들은 SetObsever 인터페이스를 구현하여 관찰자 객체를 생성한다.
- added(ObservableSet<E> set, E element) 메서드 하나만 있는 함수형 인터페이스
- 원소가 추가될 때마다 ObservableSet이 이 메서드를 호출. 이를 통해 관찰자들은 집합에 변화가 생겼을 때 알림을 받을 수 있다.

**0 ~ 99까지 출력하는 예제**

```java
import java.util.HashSet;

public class Main {
    public static void main(String[] args) {
        ObservableSet<Integer> set =
                new ObservableSet<>(new HashSet<>());

        set.addObserver((s, e) -> System.out.println(e));
        /*
        컴파일러는 이렇게 생각해요:
				addObserver의 파라미터 타입은 SetObserver<E>
				SetObserver<E>는 추상 메서드 added(ObservableSet<E> set, E element) 하나뿐
				그럼 (s, e) -> System.out.println(e)는 바로 added()의 본문이네?
				👉 따라서 자동으로 이 코드가 만들어짐:
        set.addObserver(new SetObserver<Integer>() {
		    @Override
		    public void added(ObservableSet<Integer> s, Integer e) {
		        System.out.println(e);
			    }
				});
        */

        for (int i = 0; i < 100; i++) {
            set.add(i);
        }
    }
}
```

위 코드는 아무 이상없이 0부터 99까지 출력

**문제상황 1) ConcurrentModificationException 이 발생하는 예제
: 동기화된 컬렉션을 순회하는 동안 그 컬렉션을 수정할 때 발생하는 예외**

```java
import java.util.HashSet;

public class Main {
    public static void main(String[] args) {
        ObservableSet<Integer> set =
                new ObservableSet<>(new HashSet<>());

        set.addObserver(new SetObserver<Integer>() {
            @Override
            public void added(ObservableSet<Integer> set, Integer element) {
                System.out.println(element);
                if (element == 23)
                    set.removeObserver(this);
            }
        });

        for (int i = 0; i < 100; i++) {
            set.add(i); // notifyElementAdded 호출되고 있음
        }
    }
}
```

위 코드는 아까 보았던 예제와 달리 ConcurrentModificationException을 던진다.

- 집합에 원소가 추가하면 해당 원소를 출력하고 만약 해당 원소가 23이라면 관찰자를 제거하는 로직을 구현한 예시이다.
    - 그러나 동시에 여러 스레드가 관여하면서 문제가 발생할 수 있다.

**문제 발생 과정 (단계별 설명)**

**Step 1: ObservableSet의 add 메서드 호출**

```java
**set.add(23); *// 23을 추가***
```

**Step 2: ObservableSet 내부에서 Observer들에게 알림**

```java
public boolean add(E element) {
    boolean added = set.add(element);
    if (added) {
        notifyElementAdded(element); // 모든 Observer에게 알림
    }
    return added;
}

private void notifyElementAdded(E element) {
    for (SetObserver<E> observer : observers) { // 🚨 순회 중!
        observer.added(this, element);
    }
}
```

**Step 3: Observer의 added 메서드 실행**

```java
public void added(ObservableSet<Integer> set, Integer element) {
    System.out.println(element); // 23 출력
    if (element == 23)
        set.removeObserver(this); // 🚨 observers 리스트에서 자신을 제거!
}
```

### Step 4: ConcurrentModificationException 발생!

- notifyElementAdded 메서드가 observers 리스트를 순회하는 중
- Observer가 removeObserver(this)를 호출하여 리스트를 수정
- **"순회 중인 컬렉션을 수정했다!"** → ConcurrentModificationException

**문제 상황 2) 응답 불가(교착 상태)**

```java
set.addObserver(new SetObserver<Integer>() {
		@Override
    public void added(ObservableSet<Integer> s, Integer e) {
        System.out.println(e);
        if (e == 23) {
            ExecutorService exec = Executors.newSingleThreadExecutor();
            try {
                exec.submit(() -> s.removeObserver(this)).get();
            } catch (ExecutionException | InterruptedException ex) {
                throw new AssertionError(ex);
            } finally {
                exec.shutdown();
            }
        }
    }
});
```

**문제 발생 과정 (단계별 설명)**

**Step 1: ObservableSet의 add 메서드 호출**

```java
**set.add(23); *// 23을 추가***
```

**Step 2: ObservableSet이 동기화된 상태로 Observer들에게 알림**

```java
private void notifyElementAdded(E element) {
    synchronized(observers) { // 🔒 메인 스레드가 observers 락 획득
        for (SetObserver<E> observer : observers) {
            observer.added(this, element); // Observer의 added 메서드 호출
        }
    } // 락 해제 (하지만 아직 해제되지 않음! - 왜냐면 e == 23 구문은 아직 끝나지 않았으니) 
}
```

**Step 3: Observer의 added 메서드에서 새로운 스레드 생성**

```java
public void added(ObservableSet<Integer> s, Integer e) {
    System.out.println(e); // 23 출력
    if (e == 23) {
        ExecutorService exec = Executors.newSingleThreadExecutor();
        // 새로운 스레드(Worker Thread) 생성
        // Worker Thread가 observers 락을 기다림
        exec.submit(() -> s.removeObserver(this)).get();
    }
}
```

**Step 4: 교착상태 발생! 💀**

- **메인 스레드**: observers 락을 가지고 있고, exec.submit(...).get()에서 Worker Thread 완료를 기다림
- **Worker Thread**: removeObserver()를 호출하려 하지만 observers 락을 획득하지 못해 대기
- **결과**: 서로를 무한정 기다리는 교착상태!

## 해결방안

**외계인 메서드 호출을 동기화 블록 바깥으로 옮기면 된다.  (외부 코드 호출 전에 락 해제)**

notifyElementAdded2 메서드에서라면 관찰자 리스트를 복사해 쓰면 락 없이도 안전하게 순회할 수 있다.

이 방식을 적용하면 앞서의 첫번째 시도, 두번째 시도에서 발생한 예외, 교착상태 증상이 사라진다.

```java
private void notifyElementAdded2(E element) {
    List<SetObserver<E>> snapshot = null;
    
    synchronized (observers) {
        snapshot = new ArrayList<>(observers);
    }

    for (SetObserver<E> observer : snapshot)
        observer.added(this, element);
}
```

이처럼 동기화 영역 바깥에서 호출되는 외계인 메서드를 열린 호출(open call)이라고 한다.

외계인 메서드는 얼마나 오래 실행될지 알 수 없는데, 동기화 영역 안에서 호출된다면 그동안 다른 스레드는 보호된 자원을 사용하지 못하고 대기해야만한다. 따라서 열린 호출은 실행 방지 효과 외에도 동시성 효율을 크게 개선해준다.

## 더 나은 해결방안

자바의 동시성 컬렉션 라이브러리의 CopyOnWriteArrayList가 정확히 이 목적으로 특별히 설계되었다.

ArrayList를 구현한 클래스로, 내부를 변경하는 작업은 항상 깨끗한 복사본을 만들어 수행하도록 구현했다.

내부의 배열은 절대 수정되지 않으니 순회할때 락이 필요 없어 매우 빠르다.

```java
private final List<SetObserver<E>> observers = new CopyOnWriteArrayList<>();

public void addObserver(SetObserver<E> observer) {
    observers.add(observer);
}

public boolean removeObserver(SetObserver<E> observer) {
    return observers.remove(observer);
}

private void notifyElementAdded(E element) {
    for (SetObserver<E> observer : observers)
        observer.added(this, element);
```

## 정리

자바의 동기화 비용은 빠르게 낮아져왔다. 하지만 과도환 동기화를 피하는 일은 오히려 과거 어느 때보다 중요하다.

과도한 동기화가 초래하는 진짜 비용은 락을 얻는데 드는 CPU 시간이 아닌, '경쟁하느라 낭비하는 시간, 즉 병렬로 실행할 기회를 잃고, 모든 코어가 메모리를 일관되게 보기 위한 지연시간'이 진짜 비용이다.

- 클라이언트가 넘겨준 함수는 동기화 영역 안에서 호출하면 안된다.
- 동기화 영역 안에서의 작업은 최소한으로 줄이자.
- 가변 클래스를 설계할 때는 스스로 동기화가 필요한지 고민해야한다.