# 86. Serializable을 구현할지는 신중히 결정하라
# 핵심요약

> 어떤 클래스의 인스턴스를 직렬화할 수 있게 하려면 implements Serializable만 덧붙이면 된다.
직렬화를 지원하기란 짧게 보면 손쉬워보이지만, 길게 보면 아주 값비싼 일이다.
>

# Serializable 구현의 단점들

- Serializable을 구현하면 릴리즈한 뒤에는 수정하기 어렵다.
    - **문제:**  일단 클래스를 릴리즈하고 나면, 다른 사람들이 이 직렬화된 데이터를 저장하거나 주고받기 시작한다. 만약 나중에 클래스의 내부 구조(필드 이름이나 타입 등)를 조금이라도 변경하면, **이전에 직렬화된 데이터**를 새 버전의 클래스가 읽지 못하거나, 잘못 읽는 문제가 발생할 수 있다.
    - **결과:** 클래스의 내부 구현을 바꾸는 유연성을 잃게 되고, 사실상 영원히 이전의 직렬화된 형태를 지원해야 하는 짐을 지게 된다.
- 버그와 보안 구멍이 생길 가능성이 높아진다.
    - 객체는 생성자를 사용해 만드는 게 기본인데, 직렬화는 언어 기본 메커니즘을 우회하는 객체 생성 기법이다.
    - **문제:** 역직렬화는 이 생성자를 건너뛰고 **숨겨진 생성자**처럼 동작하며 바이트 스트림으로부터 객체를 바로 만들어낸다. 이 과정에서 유효성 검사가 생략되기 쉽고, 악의적인 바이트 스트림을 주입하면 개발자가 의도하지 않은 **유효하지 않은 객체**를 만들어내거나, 심지어 **보안상 취약점**으로 이어질 수 있다. → 88 장에서 추가 설명
- 해당 클래스의 신버전을 릴리즈할 때 테스트해야 할 것이 늘어난다.
    - 직렬화 가능 클래스가 수정되면 직렬화/역직렬화가 문제 없이 진행되는지 검사해야한다.

# Serializable 구현하면 안 되는 경우

- 상속용으로 설계된 클래스는 Serializable을 구현해서는 안 되고, 인터페이스도 Serializable을 확장해서는 안 된다.
    - 클래스를 상속용으로 설계했다는 것은 누군가 이 클래스를 가져다가 기능을 확장해서 사용하리라는 것을 의미하는데, 여기에 Serializable을 붙이는 순간, 상속받는 모든 하위 클래스에 큰 짐을 지우게 된다.
    - 하위 클래스가 자신의 상태를 직렬화할 때, 상위 클래스(부모)의 상태 직렬화에도 깊이 관여해야 한다. 부모가 직렬화에 관련된 어떤 메서드(예: readObject, writeObject)를 구현하면, 자식도 그 메서드의 작동 방식을 정확히 이해하고 호환되도록 설계해야 한다.

- 내부 클래스는 직렬화를 구현하지 말아야 한다.
    - 바깥 인스턴스 참조와 유효 지역변수 값을 저장하기 위해 컴파일러가 임의로 생성한 필드가 들어가기 때문에 직렬화 형태가 일관적이지 않다.
    - 핵심 문제: 숨겨진 필드 때문에 직렬화 형태를 예측할 수 없다.

      내부 클래스는 바깥 클래스 안에 정의된 클래스로, 바깥 클래스의 멤버에 접근할 수 있다.

      내부 클래스가 바깥 클래스에 접근하기 위해, 자바 컴파일러는 자동으로 내부 클래스에 바깥 인스턴스에 대한 숨겨진 참조 필드를 추가한다. 이 필드는 개발자가 코드로 볼 수 없음

    - 직렬화 문제: 이 숨겨진 필드 때문에 내부 클래스를 직렬화하면, 바깥 인스턴스 전체가 직렬화된다.

# 정리

- Serializable은 구현한다고 선언하기는 쉽지만 눈속임이다.
- 한 클래스의 여러 버전이 상호작용할 일이 없고 서버가 신뢰할 수 없는 데이터에 노출될 가능성이 없는 등, 보호된 환경에서만 쓰일 클래스가 아니라면 Serializable 구현은 아주 신중히 이뤄져야 한다.
- 상속할 수 있는 클래스라면 더욱 주의해야한다.

# 번외

**JPA에서 복합키 클래스는 Serializable을 구현해야 함.** JPA 명세(JPA Specification)에서 **필수 요구사항**

***JPA에서 Serializable이 필요한 이유***

1. **영속성 컨텍스트 관리**: JPA가 엔티티의 식별자를 내부적으로 직렬화하여 관리
2. **캐싱**: 2차 캐시에서 엔티티를 식별하기 위해 키를 직렬화
3. **분산 환경**: 클러스터 환경에서 엔티티 식별자 전송
4. **세션 복제**: 웹 애플리케이션의 세션 복제 시 엔티티 식별자 직렬화

*안 붙이면:*

- **스펙 위반** → 다른 구현체로 옮겼을 때 동작 안 할 수 있음
- Hibernate 같은 구현체에서는 **런타임 에러**나 **캐시/세션 직렬화 문제** 발생

```java
public class AlgthrAllncoAddrMpngJpoPk implements Serializable {
    private String chnlId;
    private String allncoAddrId;
}
```