# 88. readObject 메서드는 방어적으로 작성하라

## 핵심요약

> `readObject`를 작성할 때, 일반 생성자를 작성할 때처럼 **방어적인 자세**를 취하여 조작된 바이트 스트림으로부터 안전한 객체를 복원해야한다.
>

일반적으로 자바 객체는 생성자(Constructor)를 통해서 만들어진다.
생성자에서 입력 값(매개변수)이 올바른지 확인하고, 객체의 중요한 규칙(불변식)을 깨뜨리지 않도록 보호한다.

하지만 **직렬화**된 객체를 다시 불러올 때 사용하는 **readObject 메서드**는 이 생성자를 건너뛰고 객체를 만들어낸다.

***readObject는 매개변수가 바이트 스트림인 '숨겨진 생성자'나 마찬가지이다.***

문제는 이 **바이트 스트림**이 악의적인 사용자나 잘못된 코드에 의해 **조작**될 수 있다는 점이다.

누군가 객체의 불변성(한번 만들어지면 변하지 않는 성질)을 깨뜨리거나, 객체 내부의 중요한 데이터를 손상시키는 바이트를 심어 넣을 수 있다.

아이템 50에서 가변인 Date 클래스를 사용하기 때문에 방어적 복사를 진행하여 불변식을 지켰던 클래스

```java
// 방어적 복사를 사용하는 불변 클래스
public final class Period {
    private final Date start;
    private final Date end;

    /**
     * @param start 시작 시각
     * @param end 종료 시각; 시작 시각보다 뒤여야 한다.
     * @throws IllegalArgumentException 시작 시각이 종료 시각보다 늦을 때 발생한다.
     * @throws NullPointerException start나 end가 null이면 발행한다.
     */
    public Period(Date start, Date end) {
        this.start = new Date(start.getTime());
        this.end = new Date(end.getTime());
        if(this.start.compareTo(this.end) > 0) {
            throw new IllegalArgumentException(start + "가 " + end + "보다 늦다.");
        }
    }

    public Date start() { return new Date(start.getTime()); }
    public Date end() { return new Date(end.getTime()); }
    public String toString() { return start + "-" + end; }
}
```

코드 해석)

Period 클래스의 목표는 불변 클래스로 동작하는 것이다. start ≤ end 라는 것을 보장함

하지만 매개변수 Date는 변경가능한 클래스이다.

매개변수로 받은 start와 end를 필드에 바로 저장하지 않고, new Date(start.getTime)을 이용해 새로운 복사본을 만들어 저장한다.

⇒ 외부에서 Period 객체를 만든 후에 start 객체를 바꾸더라도, Period 내부에는 이미 **복사본**이 저장되어 있기 때문에 내부 상태가 바뀌지 않는다. 이것이 **방어적 복사이다.**

이 코드만 보면 완벽하게 불변 클래스처럼 보이지만,  `implements Serializable`을 추가하는 순간, 이 방어벽에 구멍이 생긴다.

`implements Serializable` 추가 후  다음의 괴이한 프로그램 수행 시 불변식을 깨뜨리는 객체를 만들 수 있음

위의 프로그램을 실행하면 다음이 출력된다.

Fri Jan 01 12:00:00 PST **1999** - Sun Jan 01 12:00:00 PST **1984**

```java
public class BogusPeriod {
    // 진짜 Period 인스턴스에서는 만들어질 수 없는 바이트 스트림
    private static final byte[] serializedForm = {
        (byte)0xac, (byte)0xed, 0x00, 0x05, 0x73, 0x72, 0x00, 0x06,
        0x50, 0x65, 0x72, 0x69, 0x6f, 0x64, 0x40, 0x7e, (byte)0xf8,
        ... 생략

    }

    public static void main(String[] args) {
        Period p = (Period) deserialize(serializedForm);
        System.out.println(p);
    }

    static Object deserialize(byte[] sf) {
        try (ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(sf)) {
            try (ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream)) {
                return objectInputStream.readObject();
            }
        } catch (IOException | ClassNotFoundException e) {
            throw new IllegalArgumentException(e);
        }
    }
}
```

코드설명))

1. `serializedForm` (공격 코드)의 정체

- `Period` 클래스 내부의 불변식(start ≤ end)을 깨뜨리도록 **특수하게 조작된** 바이트 스트림입
- 공격자가 수동으로 만들었거나, 특정 도구를 사용해서 **시작 날짜가 종료 날짜보다 늦게 설정된 상태**로 `Period` 객체가 복원되도록 설계된 데이터

2. `deserialize` 메서드의 역할

- 외부에서 받은 바이트 배열(`serializedForm`)을 읽어서 `ObjectInputStream.readObject()`를 호출
- 이 `readObject()` 호출이 바로 숨겨진 생성자처럼 동작하며 `Period` 객체를 복원하려고 시도하는 부분

3. `main` 메서드 (공격 실행)

- 공격 코드를 실행하면, `deserialize` 메서드는 `serializedForm`을 읽어 유효성 검사가 생략된 `Period` 객체를 강제로 만들어낸다.
- 만약 `Period` 클래스에 아이템 88에서 조언하는 `readObject` 메서드가 **없다면**, 결과적으로 `p`는 start ≤ end 불변식이 깨진 객체가 된다.

# 해결방안

- **공격 경로 차단:** `Period` 클래스에 **`readObject`** 메서드를 직접 구현
- **방어 코드 추가:** 이 `readObject` 메서드 안에서 **생성자와 똑같이** 날짜의 **방어적 복사**와 **유효성 검사** 로직을 넣어준다.